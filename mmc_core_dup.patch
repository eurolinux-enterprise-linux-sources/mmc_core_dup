diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index f2eeb38..51cb1e4 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -2,7 +2,7 @@
 # MMC subsystem configuration
 #
 
-menuconfig MMC
+menuconfig MMC_DUP
 	tristate "MMC/SD/SDIO card support"
 	depends on HAS_IOMEM
 	help
@@ -19,7 +19,7 @@ config MMC_DEBUG
 	  This is an option for use by developers; most people should
 	  say N here.  This enables MMC core and driver debugging.
 
-if MMC
+if MMC_DUP
 
 source "drivers/mmc/core/Kconfig"
 
@@ -27,4 +27,4 @@ source "drivers/mmc/card/Kconfig"
 
 source "drivers/mmc/host/Kconfig"
 
-endif # MMC
+endif # MMC_DUP
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index 9979f5e..6887a69 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -6,7 +6,7 @@ ifeq ($(CONFIG_MMC_DEBUG),y)
 	EXTRA_CFLAGS		+= -DDEBUG
 endif
 
-obj-$(CONFIG_MMC)		+= core/
-obj-$(CONFIG_MMC)		+= card/
-obj-$(CONFIG_MMC)		+= host/
+obj-$(CONFIG_MMC_DUP)		+= core/
+obj-$(CONFIG_MMC_DUP)		+= card/
+obj-$(CONFIG_MMC_DUP)		+= host/
 
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index e8aeee8..9e93ea6 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -163,28 +163,28 @@ void mmc_unregister_bus(void)
 }
 
 /**
- *	mmc_register_driver - register a media driver
+ *	mmc_register_driver_dup - register a media driver
  *	@drv: MMC media driver
  */
-int mmc_register_driver(struct mmc_driver *drv)
+int mmc_register_driver_dup(struct mmc_driver *drv)
 {
 	drv->drv.bus = &mmc_bus_type;
 	return driver_register(&drv->drv);
 }
 
-EXPORT_SYMBOL(mmc_register_driver);
+EXPORT_SYMBOL(mmc_register_driver_dup);
 
 /**
- *	mmc_unregister_driver - unregister a media driver
+ *	mmc_unregister_driver_dup - unregister a media driver
  *	@drv: MMC media driver
  */
-void mmc_unregister_driver(struct mmc_driver *drv)
+void mmc_unregister_driver_dup(struct mmc_driver *drv)
 {
 	drv->drv.bus = &mmc_bus_type;
 	driver_unregister(&drv->drv);
 }
 
-EXPORT_SYMBOL(mmc_unregister_driver);
+EXPORT_SYMBOL(mmc_unregister_driver_dup);
 
 static void mmc_release_card(struct device *dev)
 {
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index d17ae99..69ac9db 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -37,6 +37,9 @@
 #include "sd_ops.h"
 #include "sdio_ops.h"
 
+#define DRIVER_VERSION "0.1-rh1"
+MODULE_VERSION(DRIVER_VERSION);
+
 static struct workqueue_struct *workqueue;
 
 /*
@@ -54,12 +57,12 @@ module_param(use_spi_crc, bool, 0);
  * overridden if necessary.
  */
 #ifdef CONFIG_MMC_UNSAFE_RESUME
-int mmc_assume_removable;
+int mmc_assume_removable_dup;
 #else
-int mmc_assume_removable = 1;
+int mmc_assume_removable_dup = 1;
 #endif
-EXPORT_SYMBOL(mmc_assume_removable);
-module_param_named(removable, mmc_assume_removable, bool, 0644);
+EXPORT_SYMBOL(mmc_assume_removable_dup);
+module_param_named(removable, mmc_assume_removable_dup, bool, 0644);
 MODULE_PARM_DESC(
 	removable,
 	"MMC/SD cards are removable and may be removed during suspend");
@@ -82,14 +85,14 @@ static void mmc_flush_scheduled_work(void)
 }
 
 /**
- *	mmc_request_done - finish processing an MMC request
+ *	mmc_request_done_dup - finish processing an MMC request
  *	@host: MMC host which completed request
  *	@mrq: MMC request which request
  *
  *	MMC drivers should call this function when they have completed
  *	their processing of a request.
  */
-void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
+void mmc_request_done_dup(struct mmc_host *host, struct mmc_request *mrq)
 {
 	struct mmc_command *cmd = mrq->cmd;
 	int err = cmd->error;
@@ -133,7 +136,7 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 	}
 }
 
-EXPORT_SYMBOL(mmc_request_done);
+EXPORT_SYMBOL(mmc_request_done_dup);
 
 static void
 mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
@@ -199,7 +202,7 @@ static void mmc_wait_done(struct mmc_request *mrq)
 }
 
 /**
- *	mmc_wait_for_req - start a request and wait for completion
+ *	mmc_wait_for_req_dup - start a request and wait for completion
  *	@host: MMC host to start command
  *	@mrq: MMC request to start
  *
@@ -207,7 +210,7 @@ static void mmc_wait_done(struct mmc_request *mrq)
  *	for the command to complete. Does not attempt to parse the
  *	response.
  */
-void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
+void mmc_wait_for_req_dup(struct mmc_host *host, struct mmc_request *mrq)
 {
 	DECLARE_COMPLETION_ONSTACK(complete);
 
@@ -219,10 +222,10 @@ void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
 	wait_for_completion(&complete);
 }
 
-EXPORT_SYMBOL(mmc_wait_for_req);
+EXPORT_SYMBOL(mmc_wait_for_req_dup);
 
 /**
- *	mmc_wait_for_cmd - start a command and wait for completion
+ *	mmc_wait_for_cmd_dup - start a command and wait for completion
  *	@host: MMC host to start command
  *	@cmd: MMC command to start
  *	@retries: maximum number of retries
@@ -231,7 +234,7 @@ EXPORT_SYMBOL(mmc_wait_for_req);
  *	to complete.  Return any error that occurred while the command
  *	was executing.  Do not attempt to parse the response.
  */
-int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries)
+int mmc_wait_for_cmd_dup(struct mmc_host *host, struct mmc_command *cmd, int retries)
 {
 	struct mmc_request mrq;
 
@@ -245,22 +248,22 @@ int mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries
 	mrq.cmd = cmd;
 	cmd->data = NULL;
 
-	mmc_wait_for_req(host, &mrq);
+	mmc_wait_for_req_dup(host, &mrq);
 
 	return cmd->error;
 }
 
-EXPORT_SYMBOL(mmc_wait_for_cmd);
+EXPORT_SYMBOL(mmc_wait_for_cmd_dup);
 
 /**
- *	mmc_set_data_timeout - set the timeout for a data command
+ *	mmc_set_data_timeout_dup - set the timeout for a data command
  *	@data: data phase for command
  *	@card: the MMC card associated with the data transfer
  *
  *	Computes the data timeout parameters according to the
  *	correct algorithm given the card type.
  */
-void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
+void mmc_set_data_timeout_dup(struct mmc_data *data, const struct mmc_card *card)
 {
 	unsigned int mult;
 
@@ -331,10 +334,10 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 		}
 	}
 }
-EXPORT_SYMBOL(mmc_set_data_timeout);
+EXPORT_SYMBOL(mmc_set_data_timeout_dup);
 
 /**
- *	mmc_align_data_size - pads a transfer size to a more optimal value
+ *	mmc_align_data_size_dup - pads a transfer size to a more optimal value
  *	@card: the MMC card associated with the data transfer
  *	@sz: original transfer size
  *
@@ -347,7 +350,7 @@ EXPORT_SYMBOL(mmc_set_data_timeout);
  *	Note that this function is only relevant when issuing a
  *	single scatter gather entry.
  */
-unsigned int mmc_align_data_size(struct mmc_card *card, unsigned int sz)
+unsigned int mmc_align_data_size_dup(struct mmc_card *card, unsigned int sz)
 {
 	/*
 	 * FIXME: We don't have a system for the controller to tell
@@ -358,17 +361,17 @@ unsigned int mmc_align_data_size(struct mmc_card *card, unsigned int sz)
 
 	return sz;
 }
-EXPORT_SYMBOL(mmc_align_data_size);
+EXPORT_SYMBOL(mmc_align_data_size_dup);
 
 /**
- *	mmc_host_enable - enable a host.
+ *	mmc_host_enable_dup - enable a host.
  *	@host: mmc host to enable
  *
  *	Hosts that support power saving can use the 'enable' and 'disable'
  *	methods to exit and enter power saving states. For more information
  *	see comments for struct mmc_host_ops.
  */
-int mmc_host_enable(struct mmc_host *host)
+int mmc_host_enable_dup(struct mmc_host *host)
 {
 	if (!(host->caps & MMC_CAP_DISABLE))
 		return 0;
@@ -400,7 +403,7 @@ int mmc_host_enable(struct mmc_host *host)
 	host->enabled = 1;
 	return 0;
 }
-EXPORT_SYMBOL(mmc_host_enable);
+EXPORT_SYMBOL(mmc_host_enable_dup);
 
 static int mmc_host_do_disable(struct mmc_host *host, int lazy)
 {
@@ -427,14 +430,14 @@ static int mmc_host_do_disable(struct mmc_host *host, int lazy)
 }
 
 /**
- *	mmc_host_disable - disable a host.
+ *	mmc_host_disable_dup - disable a host.
  *	@host: mmc host to disable
  *
  *	Hosts that support power saving can use the 'enable' and 'disable'
  *	methods to exit and enter power saving states. For more information
  *	see comments for struct mmc_host_ops.
  */
-int mmc_host_disable(struct mmc_host *host)
+int mmc_host_disable_dup(struct mmc_host *host)
 {
 	int err;
 
@@ -453,10 +456,10 @@ int mmc_host_disable(struct mmc_host *host)
 	err = mmc_host_do_disable(host, 0);
 	return err;
 }
-EXPORT_SYMBOL(mmc_host_disable);
+EXPORT_SYMBOL(mmc_host_disable_dup);
 
 /**
- *	__mmc_claim_host - exclusively claim a host
+ *	__mmc_claim_host_dup - exclusively claim a host
  *	@host: mmc host to claim
  *	@abort: whether or not the operation should be aborted
  *
@@ -465,7 +468,7 @@ EXPORT_SYMBOL(mmc_host_disable);
  *	that non-zero value without acquiring the lock.  Returns zero
  *	with the lock held otherwise.
  */
-int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
+int __mmc_claim_host_dup(struct mmc_host *host, atomic_t *abort)
 {
 	DECLARE_WAITQUEUE(wait, current);
 	unsigned long flags;
@@ -494,19 +497,19 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
 	if (!stop)
-		mmc_host_enable(host);
+		mmc_host_enable_dup(host);
 	return stop;
 }
 
-EXPORT_SYMBOL(__mmc_claim_host);
+EXPORT_SYMBOL(__mmc_claim_host_dup);
 
 /**
- *	mmc_try_claim_host - try exclusively to claim a host
+ *	mmc_try_claim_host_dup - try exclusively to claim a host
  *	@host: mmc host to claim
  *
  *	Returns %1 if the host is claimed, %0 otherwise.
  */
-int mmc_try_claim_host(struct mmc_host *host)
+int mmc_try_claim_host_dup(struct mmc_host *host)
 {
 	int claimed_host = 0;
 	unsigned long flags;
@@ -521,7 +524,7 @@ int mmc_try_claim_host(struct mmc_host *host)
 	spin_unlock_irqrestore(&host->lock, flags);
 	return claimed_host;
 }
-EXPORT_SYMBOL(mmc_try_claim_host);
+EXPORT_SYMBOL(mmc_try_claim_host_dup);
 
 static void mmc_do_release_host(struct mmc_host *host)
 {
@@ -545,21 +548,21 @@ void mmc_host_deeper_disable(struct work_struct *work)
 		container_of(work, struct mmc_host, disable.work);
 
 	/* If the host is claimed then we do not want to disable it anymore */
-	if (!mmc_try_claim_host(host))
+	if (!mmc_try_claim_host_dup(host))
 		return;
 	mmc_host_do_disable(host, 1);
 	mmc_do_release_host(host);
 }
 
 /**
- *	mmc_host_lazy_disable - lazily disable a host.
+ *	mmc_host_lazy_disable_dup - lazily disable a host.
  *	@host: mmc host to disable
  *
  *	Hosts that support power saving can use the 'enable' and 'disable'
  *	methods to exit and enter power saving states. For more information
  *	see comments for struct mmc_host_ops.
  */
-int mmc_host_lazy_disable(struct mmc_host *host)
+int mmc_host_lazy_disable_dup(struct mmc_host *host)
 {
 	if (!(host->caps & MMC_CAP_DISABLE))
 		return 0;
@@ -580,25 +583,25 @@ int mmc_host_lazy_disable(struct mmc_host *host)
 	} else
 		return mmc_host_do_disable(host, 1);
 }
-EXPORT_SYMBOL(mmc_host_lazy_disable);
+EXPORT_SYMBOL(mmc_host_lazy_disable_dup);
 
 /**
- *	mmc_release_host - release a host
+ *	mmc_release_host_dup - release a host
  *	@host: mmc host to release
  *
  *	Release a MMC host, allowing others to claim the host
  *	for their operations.
  */
-void mmc_release_host(struct mmc_host *host)
+void mmc_release_host_dup(struct mmc_host *host)
 {
 	WARN_ON(!host->claimed);
 
-	mmc_host_lazy_disable(host);
+	mmc_host_lazy_disable_dup(host);
 
 	mmc_do_release_host(host);
 }
 
-EXPORT_SYMBOL(mmc_release_host);
+EXPORT_SYMBOL(mmc_release_host_dup);
 
 /*
  * Internal function that does the actual ios call to the host driver,
@@ -706,7 +709,7 @@ static int mmc_vdd_to_ocrbitnum(int vdd, bool low_bits)
 }
 
 /**
- * mmc_vddrange_to_ocrmask - Convert a voltage range to the OCR mask
+ * mmc_vddrange_to_ocrmask_dup - Convert a voltage range to the OCR mask
  * @vdd_min:	minimum voltage value (mV)
  * @vdd_max:	maximum voltage value (mV)
  *
@@ -718,7 +721,7 @@ static int mmc_vdd_to_ocrbitnum(int vdd, bool low_bits)
  * [3300:3400] range is translated to MMC_VDD_32_33 | MMC_VDD_33_34 |
  * MMC_VDD_34_35 mask.
  */
-u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max)
+u32 mmc_vddrange_to_ocrmask_dup(int vdd_min, int vdd_max)
 {
 	u32 mask = 0;
 
@@ -741,12 +744,12 @@ u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max)
 
 	return mask;
 }
-EXPORT_SYMBOL(mmc_vddrange_to_ocrmask);
+EXPORT_SYMBOL(mmc_vddrange_to_ocrmask_dup);
 
 #ifdef CONFIG_REGULATOR
 
 /**
- * mmc_regulator_get_ocrmask - return mask of supported voltages
+ * mmc_regulator_get_ocrmask_dup - return mask of supported voltages
  * @supply: regulator to use
  *
  * This returns either a negative errno, or a mask of voltages that
@@ -754,7 +757,7 @@ EXPORT_SYMBOL(mmc_vddrange_to_ocrmask);
  * regulator.  This would normally be called before registering the
  * MMC host adapter.
  */
-int mmc_regulator_get_ocrmask(struct regulator *supply)
+int mmc_regulator_get_ocrmask_dup(struct regulator *supply)
 {
 	int			result = 0;
 	int			count;
@@ -773,15 +776,15 @@ int mmc_regulator_get_ocrmask(struct regulator *supply)
 			continue;
 
 		vdd_mV = vdd_uV / 1000;
-		result |= mmc_vddrange_to_ocrmask(vdd_mV, vdd_mV);
+		result |= mmc_vddrange_to_ocrmask_dup(vdd_mV, vdd_mV);
 	}
 
 	return result;
 }
-EXPORT_SYMBOL(mmc_regulator_get_ocrmask);
+EXPORT_SYMBOL(mmc_regulator_get_ocrmask_dup);
 
 /**
- * mmc_regulator_set_ocr - set regulator to match host->ios voltage
+ * mmc_regulator_set_ocr_dup - set regulator to match host->ios voltage
  * @vdd_bit: zero for power off, else a bit number (host->ios.vdd)
  * @supply: regulator to use
  *
@@ -791,7 +794,7 @@ EXPORT_SYMBOL(mmc_regulator_get_ocrmask);
  * a particular supply voltage.  This would normally be called from the
  * set_ios() method.
  */
-int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit)
+int mmc_regulator_set_ocr_dup(struct regulator *supply, unsigned short vdd_bit)
 {
 	int			result = 0;
 	int			min_uV, max_uV;
@@ -805,7 +808,7 @@ int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit)
 		int		tmp;
 		int		voltage;
 
-		/* REVISIT mmc_vddrange_to_ocrmask() may have set some
+		/* REVISIT mmc_vddrange_to_ocrmask_dup() may have set some
 		 * bits this regulator doesn't quite support ... don't
 		 * be too picky, most cards and regulators are OK with
 		 * a 0.1V range goof (it's a small error percentage).
@@ -838,7 +841,7 @@ int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit)
 
 	return result;
 }
-EXPORT_SYMBOL(mmc_regulator_set_ocr);
+EXPORT_SYMBOL(mmc_regulator_set_ocr_dup);
 
 #endif
 
@@ -885,7 +888,7 @@ int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 		cmd.arg = 0;
 		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
 
-		err = mmc_wait_for_cmd(host, &cmd, 0);
+		err = mmc_wait_for_cmd_dup(host, &cmd, 0);
 		if (err)
 			return err;
 
@@ -1074,7 +1077,7 @@ void mmc_detach_bus(struct mmc_host *host)
 }
 
 /**
- *	mmc_detect_change - process change of state on a MMC socket
+ *	mmc_detect_change_dup - process change of state on a MMC socket
  *	@host: host which changed state.
  *	@delay: optional delay to wait before detection (jiffies)
  *
@@ -1083,7 +1086,7 @@ void mmc_detach_bus(struct mmc_host *host)
  *	present card is still functional, and initialize any newly
  *	inserted.
  */
-void mmc_detect_change(struct mmc_host *host, unsigned long delay)
+void mmc_detect_change_dup(struct mmc_host *host, unsigned long delay)
 {
 #ifdef CONFIG_MMC_DEBUG
 	unsigned long flags;
@@ -1095,7 +1098,7 @@ void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 	mmc_schedule_delayed_work(&host->detect, delay);
 }
 
-EXPORT_SYMBOL(mmc_detect_change);
+EXPORT_SYMBOL(mmc_detect_change_dup);
 
 void mmc_init_erase(struct mmc_card *card)
 {
@@ -1146,7 +1149,7 @@ void mmc_init_erase(struct mmc_card *card)
 	}
 }
 
-static void mmc_set_mmc_erase_timeout(struct mmc_card *card,
+static void mmc_set_mmc_erase_dup_timeout(struct mmc_card *card,
 				      struct mmc_command *cmd,
 				      unsigned int arg, unsigned int qty)
 {
@@ -1200,7 +1203,7 @@ static void mmc_set_mmc_erase_timeout(struct mmc_card *card,
 
 	/*
 	 * Ensure at least a 1 second timeout for SPI as per
-	 * 'mmc_set_data_timeout()'
+	 * 'mmc_set_data_timeout_dup()'
 	 */
 	if (mmc_host_is_spi(card->host) && erase_timeout < 1000)
 		erase_timeout = 1000;
@@ -1236,7 +1239,7 @@ static void mmc_set_erase_timeout(struct mmc_card *card,
 	if (mmc_card_sd(card))
 		mmc_set_sd_erase_timeout(card, cmd, arg, qty);
 	else
-		mmc_set_mmc_erase_timeout(card, cmd, arg, qty);
+		mmc_set_mmc_erase_dup_timeout(card, cmd, arg, qty);
 }
 
 static int mmc_do_erase(struct mmc_card *card, unsigned int from,
@@ -1283,9 +1286,9 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		cmd.opcode = MMC_ERASE_GROUP_START;
 	cmd.arg = from;
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
-	err = mmc_wait_for_cmd(card->host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(card->host, &cmd, 0);
 	if (err) {
-		printk(KERN_ERR "mmc_erase: group start error %d, "
+		printk(KERN_ERR "mmc_erase_dup: group start error %d, "
 		       "status %#x\n", err, cmd.resp[0]);
 		err = -EINVAL;
 		goto out;
@@ -1298,9 +1301,9 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		cmd.opcode = MMC_ERASE_GROUP_END;
 	cmd.arg = to;
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
-	err = mmc_wait_for_cmd(card->host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(card->host, &cmd, 0);
 	if (err) {
-		printk(KERN_ERR "mmc_erase: group end error %d, status %#x\n",
+		printk(KERN_ERR "mmc_erase_dup: group end error %d, status %#x\n",
 		       err, cmd.resp[0]);
 		err = -EINVAL;
 		goto out;
@@ -1311,9 +1314,9 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	cmd.arg = arg;
 	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
 	mmc_set_erase_timeout(card, &cmd, arg, qty);
-	err = mmc_wait_for_cmd(card->host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(card->host, &cmd, 0);
 	if (err) {
-		printk(KERN_ERR "mmc_erase: erase error %d, status %#x\n",
+		printk(KERN_ERR "mmc_erase_dup: erase error %d, status %#x\n",
 		       err, cmd.resp[0]);
 		err = -EIO;
 		goto out;
@@ -1328,7 +1331,7 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 		cmd.arg = card->rca << 16;
 		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
 		/* Do not retry else we can't see errors */
-		err = mmc_wait_for_cmd(card->host, &cmd, 0);
+		err = mmc_wait_for_cmd_dup(card->host, &cmd, 0);
 		if (err || (cmd.resp[0] & 0xFDF92000)) {
 			printk(KERN_ERR "error %d requesting status %#x\n",
 				err, cmd.resp[0]);
@@ -1342,7 +1345,7 @@ out:
 }
 
 /**
- * mmc_erase - erase sectors.
+ * mmc_erase_dup - erase sectors.
  * @card: card to erase
  * @from: first sector to erase
  * @nr: number of sectors to erase
@@ -1350,7 +1353,7 @@ out:
  *
  * Caller must claim host before calling this function.
  */
-int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
+int mmc_erase_dup(struct mmc_card *card, unsigned int from, unsigned int nr,
 	      unsigned int arg)
 {
 	unsigned int rem, to = from + nr;
@@ -1406,34 +1409,34 @@ int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
 
 	return mmc_do_erase(card, from, to, arg);
 }
-EXPORT_SYMBOL(mmc_erase);
+EXPORT_SYMBOL(mmc_erase_dup);
 
-int mmc_can_erase(struct mmc_card *card)
+int mmc_can_erase_dup(struct mmc_card *card)
 {
 	if ((card->host->caps & MMC_CAP_ERASE) &&
 	    (card->csd.cmdclass & CCC_ERASE) && card->erase_size)
 		return 1;
 	return 0;
 }
-EXPORT_SYMBOL(mmc_can_erase);
+EXPORT_SYMBOL(mmc_can_erase_dup);
 
-int mmc_can_trim(struct mmc_card *card)
+int mmc_can_trim_dup(struct mmc_card *card)
 {
 	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN)
 		return 1;
 	return 0;
 }
-EXPORT_SYMBOL(mmc_can_trim);
+EXPORT_SYMBOL(mmc_can_trim_dup);
 
-int mmc_can_secure_erase_trim(struct mmc_card *card)
+int mmc_can_secure_erase_trim_dup(struct mmc_card *card)
 {
 	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN)
 		return 1;
 	return 0;
 }
-EXPORT_SYMBOL(mmc_can_secure_erase_trim);
+EXPORT_SYMBOL(mmc_can_secure_erase_trim_dup);
 
-int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
+int mmc_erase_dup_group_aligned(struct mmc_card *card, unsigned int from,
 			    unsigned int nr)
 {
 	if (!card->erase_size)
@@ -1442,9 +1445,9 @@ int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
 		return 0;
 	return 1;
 }
-EXPORT_SYMBOL(mmc_erase_group_aligned);
+EXPORT_SYMBOL(mmc_erase_dup_group_aligned);
 
-int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
+int mmc_set_blocklen_dup(struct mmc_card *card, unsigned int blocklen)
 {
 	struct mmc_command cmd;
 
@@ -1455,9 +1458,9 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 	cmd.opcode = MMC_SET_BLOCKLEN;
 	cmd.arg = blocklen;
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
-	return mmc_wait_for_cmd(card->host, &cmd, 5);
+	return mmc_wait_for_cmd_dup(card->host, &cmd, 5);
 }
-EXPORT_SYMBOL(mmc_set_blocklen);
+EXPORT_SYMBOL(mmc_set_blocklen_dup);
 
 static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 {
@@ -1528,7 +1531,7 @@ void mmc_rescan(struct work_struct *work)
 		if (freqs[i] < host->f_min)
 			break;
 	}
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
  out:
 	if (host->caps & MMC_CAP_NEEDS_POLL)
@@ -1538,7 +1541,7 @@ void mmc_rescan(struct work_struct *work)
 void mmc_start_host(struct mmc_host *host)
 {
 	mmc_power_off(host);
-	mmc_detect_change(host, 0);
+	mmc_detect_change_dup(host, 0);
 }
 
 void mmc_stop_host(struct mmc_host *host)
@@ -1565,7 +1568,7 @@ void mmc_stop_host(struct mmc_host *host)
 
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
-		mmc_release_host(host);
+		mmc_release_host_dup(host);
 		mmc_bus_put(host);
 		return;
 	}
@@ -1576,7 +1579,7 @@ void mmc_stop_host(struct mmc_host *host)
 	mmc_power_off(host);
 }
 
-int mmc_power_save_host(struct mmc_host *host)
+int mmc_power_save_host_dup(struct mmc_host *host)
 {
 	int ret = 0;
 
@@ -1596,9 +1599,9 @@ int mmc_power_save_host(struct mmc_host *host)
 
 	return ret;
 }
-EXPORT_SYMBOL(mmc_power_save_host);
+EXPORT_SYMBOL(mmc_power_save_host_dup);
 
-int mmc_power_restore_host(struct mmc_host *host)
+int mmc_power_restore_host_dup(struct mmc_host *host)
 {
 	int ret;
 
@@ -1616,9 +1619,9 @@ int mmc_power_restore_host(struct mmc_host *host)
 
 	return ret;
 }
-EXPORT_SYMBOL(mmc_power_restore_host);
+EXPORT_SYMBOL(mmc_power_restore_host_dup);
 
-int mmc_card_awake(struct mmc_host *host)
+int mmc_card_awake_dup(struct mmc_host *host)
 {
 	int err = -ENOSYS;
 
@@ -1631,9 +1634,9 @@ int mmc_card_awake(struct mmc_host *host)
 
 	return err;
 }
-EXPORT_SYMBOL(mmc_card_awake);
+EXPORT_SYMBOL(mmc_card_awake_dup);
 
-int mmc_card_sleep(struct mmc_host *host)
+int mmc_card_sleep_dup(struct mmc_host *host)
 {
 	int err = -ENOSYS;
 
@@ -1646,9 +1649,9 @@ int mmc_card_sleep(struct mmc_host *host)
 
 	return err;
 }
-EXPORT_SYMBOL(mmc_card_sleep);
+EXPORT_SYMBOL(mmc_card_sleep_dup);
 
-int mmc_card_can_sleep(struct mmc_host *host)
+int mmc_card_can_sleep_dup(struct mmc_host *host)
 {
 	struct mmc_card *card = host->card;
 
@@ -1656,16 +1659,16 @@ int mmc_card_can_sleep(struct mmc_host *host)
 		return 1;
 	return 0;
 }
-EXPORT_SYMBOL(mmc_card_can_sleep);
+EXPORT_SYMBOL(mmc_card_can_sleep_dup);
 
 #ifdef CONFIG_PM
 
 /**
- *	mmc_suspend_host - suspend a host
+ *	mmc_suspend_host_dup - suspend a host
  *	@host: mmc host
  *	@state: suspend mode (PM_SUSPEND_xxx)
  */
-int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
+int mmc_suspend_host_dup(struct mmc_host *host, pm_message_t state)
 {
 	int err = 0;
 
@@ -1685,7 +1688,7 @@ int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 				host->bus_ops->remove(host);
 			mmc_claim_host(host);
 			mmc_detach_bus(host);
-			mmc_release_host(host);
+			mmc_release_host_dup(host);
 			host->pm_flags = 0;
 			err = 0;
 		}
@@ -1698,13 +1701,13 @@ int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 	return err;
 }
 
-EXPORT_SYMBOL(mmc_suspend_host);
+EXPORT_SYMBOL(mmc_suspend_host_dup);
 
 /**
- *	mmc_resume_host - resume a previously suspended host
+ *	mmc_resume_host_dup - resume a previously suspended host
  *	@host: mmc host
  */
-int mmc_resume_host(struct mmc_host *host)
+int mmc_resume_host_dup(struct mmc_host *host)
 {
 	int err = 0;
 
@@ -1727,7 +1730,7 @@ int mmc_resume_host(struct mmc_host *host)
 
 	return err;
 }
-EXPORT_SYMBOL(mmc_resume_host);
+EXPORT_SYMBOL(mmc_resume_host_dup);
 
 /* Do the card removal on suspend if card is assumed removeable
  * Do that in pm notifier while userspace isn't yet frozen, so we will be able
@@ -1759,7 +1762,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 			host->bus_ops->remove(host);
 
 		mmc_detach_bus(host);
-		mmc_release_host(host);
+		mmc_release_host_dup(host);
 		host->pm_flags = 0;
 		break;
 
@@ -1769,7 +1772,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 0;
 		spin_unlock_irqrestore(&host->lock, flags);
-		mmc_detect_change(host, 0);
+		mmc_detect_change_dup(host, 0);
 
 	}
 
@@ -1781,6 +1784,15 @@ static int __init mmc_init(void)
 {
 	int ret;
 
+	struct module *mod;
+
+	mod = find_module("mmc_core");
+	if (mod) {
+		printk(KERN_ALERT 
+		"mmc_core_dup can not be insmoded if mmc_core module is already insmoded !\n");
+		return -EINVAL;
+	}
+
 	workqueue = create_freezeable_workqueue("kmmcd");
 	if (!workqueue)
 		return -ENOMEM;
diff --git a/drivers/mmc/core/core.h b/drivers/mmc/core/core.h
index 76825a0..6f23ab0 100644
--- a/drivers/mmc/core/core.h
+++ b/drivers/mmc/core/core.h
@@ -64,8 +64,8 @@ int mmc_attach_sdio(struct mmc_host *host);
 extern int use_spi_crc;
 
 /* Debugfs information for hosts and cards */
-void mmc_add_host_debugfs(struct mmc_host *host);
-void mmc_remove_host_debugfs(struct mmc_host *host);
+void mmc_add_host_dup_debugfs(struct mmc_host *host);
+void mmc_remove_host_dup_debugfs(struct mmc_host *host);
 
 void mmc_add_card_debugfs(struct mmc_card *card);
 void mmc_remove_card_debugfs(struct mmc_card *card);
diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c
index 96d10f4..221c55a 100644
--- a/drivers/mmc/core/debugfs.c
+++ b/drivers/mmc/core/debugfs.c
@@ -133,7 +133,7 @@ static const struct file_operations mmc_ios_fops = {
 	.release	= single_release,
 };
 
-void mmc_add_host_debugfs(struct mmc_host *host)
+void mmc_add_host_dup_debugfs(struct mmc_host *host)
 {
 	struct dentry *root;
 
@@ -160,7 +160,7 @@ err_root:
 	dev_err(&host->class_dev, "failed to initialize debugfs\n");
 }
 
-void mmc_remove_host_debugfs(struct mmc_host *host)
+void mmc_remove_host_dup_debugfs(struct mmc_host *host)
 {
 	debugfs_remove_recursive(host->debugfs_root);
 }
@@ -177,7 +177,7 @@ static int mmc_dbg_card_status_get(void *data, u64 *val)
 	if (!ret)
 		*val = status;
 
-	mmc_release_host(card->host);
+	mmc_release_host_dup(card->host);
 
 	return ret;
 }
@@ -206,7 +206,7 @@ static int mmc_ext_csd_open(struct inode *inode, struct file *filp)
 
 	mmc_claim_host(card->host);
 	err = mmc_send_ext_csd(card, ext_csd);
-	mmc_release_host(card->host);
+	mmc_release_host_dup(card->host);
 	if (err)
 		goto out_free;
 
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index c4f57fd..a5b5fd4 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -50,13 +50,13 @@ static DEFINE_IDR(mmc_host_idr);
 static DEFINE_SPINLOCK(mmc_host_lock);
 
 /**
- *	mmc_alloc_host - initialise the per-host structure.
+ *	mmc_alloc_host_dup - initialise the per-host structure.
  *	@extra: sizeof private data structure
  *	@dev: pointer to host device model structure
  *
  *	Initialise the per-host structure.
  */
-struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
+struct mmc_host *mmc_alloc_host_dup(int extra, struct device *dev)
 {
 	int err;
 	struct mmc_host *host;
@@ -106,17 +106,17 @@ free:
 	return NULL;
 }
 
-EXPORT_SYMBOL(mmc_alloc_host);
+EXPORT_SYMBOL(mmc_alloc_host_dup);
 
 /**
- *	mmc_add_host - initialise host hardware
+ *	mmc_add_host_dup - initialise host hardware
  *	@host: mmc host
  *
  *	Register the host with the driver model. The host must be
  *	prepared to start servicing requests before this function
  *	completes.
  */
-int mmc_add_host(struct mmc_host *host)
+int mmc_add_host_dup(struct mmc_host *host)
 {
 	int err;
 
@@ -130,7 +130,7 @@ int mmc_add_host(struct mmc_host *host)
 		return err;
 
 #ifdef CONFIG_DEBUG_FS
-	mmc_add_host_debugfs(host);
+	mmc_add_host_dup_debugfs(host);
 #endif
 
 	mmc_start_host(host);
@@ -139,23 +139,23 @@ int mmc_add_host(struct mmc_host *host)
 	return 0;
 }
 
-EXPORT_SYMBOL(mmc_add_host);
+EXPORT_SYMBOL(mmc_add_host_dup);
 
 /**
- *	mmc_remove_host - remove host hardware
+ *	mmc_remove_host_dup - remove host hardware
  *	@host: mmc host
  *
  *	Unregister and remove all cards associated with this host,
  *	and power down the MMC bus. No new requests will be issued
  *	after this function has returned.
  */
-void mmc_remove_host(struct mmc_host *host)
+void mmc_remove_host_dup(struct mmc_host *host)
 {
 	unregister_pm_notifier(&host->pm_notify);
 	mmc_stop_host(host);
 
 #ifdef CONFIG_DEBUG_FS
-	mmc_remove_host_debugfs(host);
+	mmc_remove_host_dup_debugfs(host);
 #endif
 
 	device_del(&host->class_dev);
@@ -164,15 +164,15 @@ void mmc_remove_host(struct mmc_host *host)
 
 }
 
-EXPORT_SYMBOL(mmc_remove_host);
+EXPORT_SYMBOL(mmc_remove_host_dup);
 
 /**
- *	mmc_free_host - free the host structure
+ *	mmc_free_host_dup - free the host structure
  *	@host: mmc host
  *
  *	Free the host once all references to it have been dropped.
  */
-void mmc_free_host(struct mmc_host *host)
+void mmc_free_host_dup(struct mmc_host *host)
 {
 	spin_lock(&mmc_host_lock);
 	idr_remove(&mmc_host_idr, host->index);
@@ -181,5 +181,5 @@ void mmc_free_host(struct mmc_host *host)
 	put_device(&host->class_dev);
 }
 
-EXPORT_SYMBOL(mmc_free_host);
+EXPORT_SYMBOL(mmc_free_host_dup);
 
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 51b571f..3871bcc 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -630,14 +630,14 @@ static void mmc_detect(struct mmc_host *host)
 	 */
 	err = mmc_send_status(host->card, NULL);
 
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	if (err) {
 		mmc_remove(host);
 
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
-		mmc_release_host(host);
+		mmc_release_host_dup(host);
 	}
 }
 
@@ -653,7 +653,7 @@ static int mmc_suspend(struct mmc_host *host)
 	if (!mmc_host_is_spi(host))
 		mmc_deselect_cards(host);
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	return 0;
 }
@@ -673,7 +673,7 @@ static int mmc_resume(struct mmc_host *host)
 
 	mmc_claim_host(host);
 	err = mmc_init_card(host, host->ocr, host->card);
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	return err;
 }
@@ -685,7 +685,7 @@ static int mmc_power_restore(struct mmc_host *host)
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_claim_host(host);
 	ret = mmc_init_card(host, host->ocr, host->card);
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	return ret;
 }
@@ -696,7 +696,7 @@ static int mmc_sleep(struct mmc_host *host)
 	int err = -ENOSYS;
 
 	if (card && card->ext_csd.rev >= 3) {
-		err = mmc_card_sleepawake(host, 1);
+		err = mmc_card_sleep_dupawake(host, 1);
 		if (err < 0)
 			pr_debug("%s: Error %d while putting card into sleep",
 				 mmc_hostname(host), err);
@@ -711,7 +711,7 @@ static int mmc_awake(struct mmc_host *host)
 	int err = -ENOSYS;
 
 	if (card && card->ext_csd.rev >= 3) {
-		err = mmc_card_sleepawake(host, 0);
+		err = mmc_card_sleep_dupawake(host, 0);
 		if (err < 0)
 			pr_debug("%s: Error %d while awaking sleeping card",
 				 mmc_hostname(host), err);
@@ -805,7 +805,7 @@ int mmc_attach_mmc(struct mmc_host *host)
 	if (err)
 		goto err;
 
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 	err = mmc_add_card(host->card);
 	mmc_claim_host(host);
 	if (err)
@@ -814,7 +814,7 @@ int mmc_attach_mmc(struct mmc_host *host)
 	return 0;
 
 remove_card:
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 	mmc_remove_card(host->card);
 	mmc_claim_host(host);
 	host->card = NULL;
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 2c600c6..3199589 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -38,7 +38,7 @@ static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)
 		cmd.flags = MMC_RSP_NONE | MMC_CMD_AC;
 	}
 
-	err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
+	err = mmc_wait_for_cmd_dup(host, &cmd, MMC_CMD_RETRIES);
 	if (err)
 		return err;
 
@@ -57,7 +57,7 @@ int mmc_deselect_cards(struct mmc_host *host)
 	return _mmc_select_card(host, NULL);
 }
 
-int mmc_card_sleepawake(struct mmc_host *host, int sleep)
+int mmc_card_sleep_dupawake(struct mmc_host *host, int sleep)
 {
 	struct mmc_command cmd;
 	struct mmc_card *card = host->card;
@@ -74,7 +74,7 @@ int mmc_card_sleepawake(struct mmc_host *host, int sleep)
 		cmd.arg |= 1 << 15;
 
 	cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
-	err = mmc_wait_for_cmd(host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(host, &cmd, 0);
 	if (err)
 		return err;
 
@@ -118,7 +118,7 @@ int mmc_go_idle(struct mmc_host *host)
 	cmd.arg = 0;
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_NONE | MMC_CMD_BC;
 
-	err = mmc_wait_for_cmd(host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(host, &cmd, 0);
 
 	mmc_delay(1);
 
@@ -146,7 +146,7 @@ int mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;
 
 	for (i = 100; i; i--) {
-		err = mmc_wait_for_cmd(host, &cmd, 0);
+		err = mmc_wait_for_cmd_dup(host, &cmd, 0);
 		if (err)
 			break;
 
@@ -188,7 +188,7 @@ int mmc_all_send_cid(struct mmc_host *host, u32 *cid)
 	cmd.arg = 0;
 	cmd.flags = MMC_RSP_R2 | MMC_CMD_BCR;
 
-	err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
+	err = mmc_wait_for_cmd_dup(host, &cmd, MMC_CMD_RETRIES);
 	if (err)
 		return err;
 
@@ -211,7 +211,7 @@ int mmc_set_relative_addr(struct mmc_card *card)
 	cmd.arg = card->rca << 16;
 	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
 
-	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+	err = mmc_wait_for_cmd_dup(card->host, &cmd, MMC_CMD_RETRIES);
 	if (err)
 		return err;
 
@@ -233,7 +233,7 @@ mmc_send_cxd_native(struct mmc_host *host, u32 arg, u32 *cxd, int opcode)
 	cmd.arg = arg;
 	cmd.flags = MMC_RSP_R2 | MMC_CMD_AC;
 
-	err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
+	err = mmc_wait_for_cmd_dup(host, &cmd, MMC_CMD_RETRIES);
 	if (err)
 		return err;
 
@@ -292,9 +292,9 @@ mmc_send_cxd_data(struct mmc_card *card, struct mmc_host *host,
 		data.timeout_ns = 0;
 		data.timeout_clks = 64;
 	} else
-		mmc_set_data_timeout(&data, card);
+		mmc_set_data_timeout_dup(&data, card);
 
-	mmc_wait_for_req(host, &mrq);
+	mmc_wait_for_req_dup(host, &mrq);
 
 	memcpy(buf, data_buf, len);
 	kfree(data_buf);
@@ -363,7 +363,7 @@ int mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp)
 	cmd.arg = highcap ? (1 << 30) : 0;
 	cmd.flags = MMC_RSP_SPI_R3;
 
-	err = mmc_wait_for_cmd(host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(host, &cmd, 0);
 
 	*ocrp = cmd.resp[1];
 	return err;
@@ -380,7 +380,7 @@ int mmc_spi_set_crc(struct mmc_host *host, int use_crc)
 	cmd.flags = MMC_RSP_SPI_R1;
 	cmd.arg = use_crc;
 
-	err = mmc_wait_for_cmd(host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(host, &cmd, 0);
 	if (!err)
 		host->use_spi_crc = use_crc;
 	return err;
@@ -404,7 +404,7 @@ int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value)
 		  set;
 	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
 
-	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+	err = mmc_wait_for_cmd_dup(card->host, &cmd, MMC_CMD_RETRIES);
 	if (err)
 		return err;
 
@@ -448,7 +448,7 @@ int mmc_send_status(struct mmc_card *card, u32 *status)
 		cmd.arg = card->rca << 16;
 	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
 
-	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+	err = mmc_wait_for_cmd_dup(card->host, &cmd, MMC_CMD_RETRIES);
 	if (err)
 		return err;
 
@@ -522,7 +522,7 @@ mmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,
 	data.sg = &sg;
 	data.sg_len = 1;
 	sg_init_one(&sg, data_buf, len);
-	mmc_wait_for_req(host, &mrq);
+	mmc_wait_for_req_dup(host, &mrq);
 	err = 0;
 	if (opcode == MMC_BUS_TEST_R) {
 		for (i = 0; i < len / 4; i++)
diff --git a/drivers/mmc/core/mmc_ops.h b/drivers/mmc/core/mmc_ops.h
index e6d44b8..39b7dd6 100644
--- a/drivers/mmc/core/mmc_ops.h
+++ b/drivers/mmc/core/mmc_ops.h
@@ -25,7 +25,7 @@ int mmc_send_status(struct mmc_card *card, u32 *status);
 int mmc_send_cid(struct mmc_host *host, u32 *cid);
 int mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp);
 int mmc_spi_set_crc(struct mmc_host *host, int use_crc);
-int mmc_card_sleepawake(struct mmc_host *host, int sleep);
+int mmc_card_sleep_dupawake(struct mmc_host *host, int sleep);
 int mmc_bus_test(struct mmc_card *card, u8 bus_width);
 
 #endif
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 8c9bfe8..d5b5a6e 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -1022,14 +1022,14 @@ static void mmc_sd_detect(struct mmc_host *host)
 	 */
 	err = mmc_send_status(host->card, NULL);
 
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	if (err) {
 		mmc_sd_remove(host);
 
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
-		mmc_release_host(host);
+		mmc_release_host_dup(host);
 	}
 }
 
@@ -1045,7 +1045,7 @@ static int mmc_sd_suspend(struct mmc_host *host)
 	if (!mmc_host_is_spi(host))
 		mmc_deselect_cards(host);
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	return 0;
 }
@@ -1065,7 +1065,7 @@ static int mmc_sd_resume(struct mmc_host *host)
 
 	mmc_claim_host(host);
 	err = mmc_sd_init_card(host, host->ocr, host->card);
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	return err;
 }
@@ -1077,7 +1077,7 @@ static int mmc_sd_power_restore(struct mmc_host *host)
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_claim_host(host);
 	ret = mmc_sd_init_card(host, host->ocr, host->card);
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	return ret;
 }
@@ -1181,7 +1181,7 @@ int mmc_attach_sd(struct mmc_host *host)
 	if (err)
 		goto err;
 
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 	err = mmc_add_card(host->card);
 	mmc_claim_host(host);
 	if (err)
@@ -1190,7 +1190,7 @@ int mmc_attach_sd(struct mmc_host *host)
 	return 0;
 
 remove_card:
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 	mmc_remove_card(host->card);
 	host->card = NULL;
 	mmc_claim_host(host);
diff --git a/drivers/mmc/core/sd_ops.c b/drivers/mmc/core/sd_ops.c
index 7ca5774..35f3d86 100644
--- a/drivers/mmc/core/sd_ops.c
+++ b/drivers/mmc/core/sd_ops.c
@@ -38,7 +38,7 @@ static int mmc_app_cmd(struct mmc_host *host, struct mmc_card *card)
 		cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_BCR;
 	}
 
-	err = mmc_wait_for_cmd(host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(host, &cmd, 0);
 	if (err)
 		return err;
 
@@ -50,7 +50,7 @@ static int mmc_app_cmd(struct mmc_host *host, struct mmc_card *card)
 }
 
 /**
- *	mmc_wait_for_app_cmd - start an application command and wait for
+ *	mmc_wait_for_app_cmd_dup - start an application command and wait for
  			       completion
  *	@host: MMC host to start command
  *	@card: Card to send MMC_APP_CMD to
@@ -62,7 +62,7 @@ static int mmc_app_cmd(struct mmc_host *host, struct mmc_card *card)
  *	that occurred while the command was executing.  Do not attempt to
  *	parse the response.
  */
-int mmc_wait_for_app_cmd(struct mmc_host *host, struct mmc_card *card,
+int mmc_wait_for_app_cmd_dup(struct mmc_host *host, struct mmc_card *card,
 	struct mmc_command *cmd, int retries)
 {
 	struct mmc_request mrq;
@@ -99,7 +99,7 @@ int mmc_wait_for_app_cmd(struct mmc_host *host, struct mmc_card *card,
 		mrq.cmd = cmd;
 		cmd->data = NULL;
 
-		mmc_wait_for_req(host, &mrq);
+		mmc_wait_for_req_dup(host, &mrq);
 
 		err = cmd->error;
 		if (!cmd->error)
@@ -115,7 +115,7 @@ int mmc_wait_for_app_cmd(struct mmc_host *host, struct mmc_card *card,
 	return err;
 }
 
-EXPORT_SYMBOL(mmc_wait_for_app_cmd);
+EXPORT_SYMBOL(mmc_wait_for_app_cmd_dup);
 
 int mmc_app_set_bus_width(struct mmc_card *card, int width)
 {
@@ -141,7 +141,7 @@ int mmc_app_set_bus_width(struct mmc_card *card, int width)
 		return -EINVAL;
 	}
 
-	err = mmc_wait_for_app_cmd(card->host, card, &cmd, MMC_CMD_RETRIES);
+	err = mmc_wait_for_app_cmd_dup(card->host, card, &cmd, MMC_CMD_RETRIES);
 	if (err)
 		return err;
 
@@ -165,7 +165,7 @@ int mmc_send_app_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
 	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;
 
 	for (i = 100; i; i--) {
-		err = mmc_wait_for_app_cmd(host, NULL, &cmd, MMC_CMD_RETRIES);
+		err = mmc_wait_for_app_cmd_dup(host, NULL, &cmd, MMC_CMD_RETRIES);
 		if (err)
 			break;
 
@@ -209,7 +209,7 @@ int mmc_send_if_cond(struct mmc_host *host, u32 ocr)
 	cmd.arg = ((ocr & 0xFF8000) != 0) << 8 | test_pattern;
 	cmd.flags = MMC_RSP_SPI_R7 | MMC_RSP_R7 | MMC_CMD_BCR;
 
-	err = mmc_wait_for_cmd(host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(host, &cmd, 0);
 	if (err)
 		return err;
 
@@ -238,7 +238,7 @@ int mmc_send_relative_addr(struct mmc_host *host, unsigned int *rca)
 	cmd.arg = 0;
 	cmd.flags = MMC_RSP_R6 | MMC_CMD_BCR;
 
-	err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
+	err = mmc_wait_for_cmd_dup(host, &cmd, MMC_CMD_RETRIES);
 	if (err)
 		return err;
 
@@ -284,9 +284,9 @@ int mmc_app_send_scr(struct mmc_card *card, u32 *scr)
 
 	sg_init_one(&sg, scr, 8);
 
-	mmc_set_data_timeout(&data, card);
+	mmc_set_data_timeout_dup(&data, card);
 
-	mmc_wait_for_req(card->host, &mrq);
+	mmc_wait_for_req_dup(card->host, &mrq);
 
 	if (cmd.error)
 		return cmd.error;
@@ -336,9 +336,9 @@ int mmc_sd_switch(struct mmc_card *card, int mode, int group,
 
 	sg_init_one(&sg, resp, 64);
 
-	mmc_set_data_timeout(&data, card);
+	mmc_set_data_timeout_dup(&data, card);
 
-	mmc_wait_for_req(card->host, &mrq);
+	mmc_wait_for_req_dup(card->host, &mrq);
 
 	if (cmd.error)
 		return cmd.error;
@@ -385,9 +385,9 @@ int mmc_app_sd_status(struct mmc_card *card, void *ssr)
 
 	sg_init_one(&sg, ssr, 64);
 
-	mmc_set_data_timeout(&data, card);
+	mmc_set_data_timeout_dup(&data, card);
 
-	mmc_wait_for_req(card->host, &mrq);
+	mmc_wait_for_req_dup(card->host, &mrq);
 
 	if (cmd.error)
 		return cmd.error;
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 6649045..0dc3811 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -487,14 +487,14 @@ static void mmc_sdio_detect(struct mmc_host *host)
 	 */
 	err = mmc_select_card(host->card);
 
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	if (err) {
 		mmc_sdio_remove(host);
 
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
-		mmc_release_host(host);
+		mmc_release_host_dup(host);
 	}
 }
 
@@ -541,7 +541,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	/* Basic card reinitialization. */
 	mmc_claim_host(host);
 	err = mmc_sdio_init_card(host, host->ocr, host->card);
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 
 	/*
 	 * If the card looked to be the same as before suspending, then
@@ -637,7 +637,7 @@ int mmc_attach_sdio(struct mmc_host *host)
 	/*
 	 * First add the card to the driver model...
 	 */
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 	err = mmc_add_card(host->card);
 	mmc_claim_host(host);
 	if (err)
@@ -657,12 +657,12 @@ int mmc_attach_sdio(struct mmc_host *host)
 
 remove_added:
 	/* Remove without lock if the device has been added. */
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 	mmc_sdio_remove(host);
 	mmc_claim_host(host);
 remove:
 	/* And with lock if it hasn't been added. */
-	mmc_release_host(host);
+	mmc_release_host_dup(host);
 	if (host->card)
 		mmc_sdio_remove(host);
 	mmc_claim_host(host);
diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index d37464e..f5dfca8 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -126,9 +126,9 @@ static int sdio_bus_probe(struct device *dev)
 
 	/* Set the default block size so the driver is sure it's something
 	 * sensible. */
-	sdio_claim_host(func);
-	ret = sdio_set_block_size(func, 0);
-	sdio_release_host(func);
+	sdio_claim_host_dup(func);
+	ret = sdio_set_block_size_dup(func, 0);
+	sdio_release_host_dup(func);
 	if (ret)
 		return ret;
 
@@ -145,9 +145,9 @@ static int sdio_bus_remove(struct device *dev)
 	if (func->irq_handler) {
 		printk(KERN_WARNING "WARNING: driver %s did not remove "
 			"its interrupt handler!\n", drv->name);
-		sdio_claim_host(func);
-		sdio_release_irq(func);
-		sdio_release_host(func);
+		sdio_claim_host_dup(func);
+		sdio_release_irq_dup(func);
+		sdio_release_host_dup(func);
 	}
 
 	return 0;
@@ -173,27 +173,27 @@ void sdio_unregister_bus(void)
 }
 
 /**
- *	sdio_register_driver - register a function driver
+ *	sdio_register_driver_dup - register a function driver
  *	@drv: SDIO function driver
  */
-int sdio_register_driver(struct sdio_driver *drv)
+int sdio_register_driver_dup(struct sdio_driver *drv)
 {
 	drv->drv.name = drv->name;
 	drv->drv.bus = &sdio_bus_type;
 	return driver_register(&drv->drv);
 }
-EXPORT_SYMBOL_GPL(sdio_register_driver);
+EXPORT_SYMBOL_GPL(sdio_register_driver_dup);
 
 /**
- *	sdio_unregister_driver - unregister a function driver
+ *	sdio_unregister_driver_dup - unregister a function driver
  *	@drv: SDIO function driver
  */
-void sdio_unregister_driver(struct sdio_driver *drv)
+void sdio_unregister_driver_dup(struct sdio_driver *drv)
 {
 	drv->drv.bus = &sdio_bus_type;
 	driver_unregister(&drv->drv);
 }
-EXPORT_SYMBOL_GPL(sdio_unregister_driver);
+EXPORT_SYMBOL_GPL(sdio_unregister_driver_dup);
 
 static void sdio_release_func(struct device *dev)
 {
diff --git a/drivers/mmc/core/sdio_io.c b/drivers/mmc/core/sdio_io.c
index 0f687cd..83bc7dd 100644
--- a/drivers/mmc/core/sdio_io.c
+++ b/drivers/mmc/core/sdio_io.c
@@ -17,45 +17,45 @@
 #include "sdio_ops.h"
 
 /**
- *	sdio_claim_host - exclusively claim a bus for a certain SDIO function
+ *	sdio_claim_host_dup - exclusively claim a bus for a certain SDIO function
  *	@func: SDIO function that will be accessed
  *
  *	Claim a bus for a set of operations. The SDIO function given
  *	is used to figure out which bus is relevant.
  */
-void sdio_claim_host(struct sdio_func *func)
+void sdio_claim_host_dup(struct sdio_func *func)
 {
 	BUG_ON(!func);
 	BUG_ON(!func->card);
 
 	mmc_claim_host(func->card->host);
 }
-EXPORT_SYMBOL_GPL(sdio_claim_host);
+EXPORT_SYMBOL_GPL(sdio_claim_host_dup);
 
 /**
- *	sdio_release_host - release a bus for a certain SDIO function
+ *	sdio_release_host_dup - release a bus for a certain SDIO function
  *	@func: SDIO function that was accessed
  *
  *	Release a bus, allowing others to claim the bus for their
  *	operations.
  */
-void sdio_release_host(struct sdio_func *func)
+void sdio_release_host_dup(struct sdio_func *func)
 {
 	BUG_ON(!func);
 	BUG_ON(!func->card);
 
-	mmc_release_host(func->card->host);
+	mmc_release_host_dup(func->card->host);
 }
-EXPORT_SYMBOL_GPL(sdio_release_host);
+EXPORT_SYMBOL_GPL(sdio_release_host_dup);
 
 /**
- *	sdio_enable_func - enables a SDIO function for usage
+ *	sdio_enable_func_dup - enables a SDIO function for usage
  *	@func: SDIO function to enable
  *
  *	Powers up and activates a SDIO function so that register
  *	access is possible.
  */
-int sdio_enable_func(struct sdio_func *func)
+int sdio_enable_func_dup(struct sdio_func *func)
 {
 	int ret;
 	unsigned char reg;
@@ -97,16 +97,16 @@ err:
 	pr_debug("SDIO: Failed to enable device %s\n", sdio_func_id(func));
 	return ret;
 }
-EXPORT_SYMBOL_GPL(sdio_enable_func);
+EXPORT_SYMBOL_GPL(sdio_enable_func_dup);
 
 /**
- *	sdio_disable_func - disable a SDIO function
+ *	sdio_disable_func_dup - disable a SDIO function
  *	@func: SDIO function to disable
  *
  *	Powers down and deactivates a SDIO function. Register access
  *	to this function will fail until the function is reenabled.
  */
-int sdio_disable_func(struct sdio_func *func)
+int sdio_disable_func_dup(struct sdio_func *func)
 {
 	int ret;
 	unsigned char reg;
@@ -134,10 +134,10 @@ err:
 	pr_debug("SDIO: Failed to disable device %s\n", sdio_func_id(func));
 	return -EIO;
 }
-EXPORT_SYMBOL_GPL(sdio_disable_func);
+EXPORT_SYMBOL_GPL(sdio_disable_func_dup);
 
 /**
- *	sdio_set_block_size - set the block size of an SDIO function
+ *	sdio_set_block_size_dup - set the block size of an SDIO function
  *	@func: SDIO function to change
  *	@blksz: new block size or 0 to use the default.
  *
@@ -155,7 +155,7 @@ EXPORT_SYMBOL_GPL(sdio_disable_func);
  *	size register writes failed.
  *
  */
-int sdio_set_block_size(struct sdio_func *func, unsigned blksz)
+int sdio_set_block_size_dup(struct sdio_func *func, unsigned blksz)
 {
 	int ret;
 
@@ -180,7 +180,7 @@ int sdio_set_block_size(struct sdio_func *func, unsigned blksz)
 	func->cur_blksize = blksz;
 	return 0;
 }
-EXPORT_SYMBOL_GPL(sdio_set_block_size);
+EXPORT_SYMBOL_GPL(sdio_set_block_size_dup);
 
 /*
  * Calculate the maximum byte mode transfer size
@@ -199,7 +199,7 @@ static inline unsigned int sdio_max_byte_size(struct sdio_func *func)
 }
 
 /**
- *	sdio_align_size - pads a transfer size to a more optimal value
+ *	sdio_align_size_dup - pads a transfer size to a more optimal value
  *	@func: SDIO function
  *	@sz: original transfer size
  *
@@ -212,7 +212,7 @@ static inline unsigned int sdio_max_byte_size(struct sdio_func *func)
  *
  *	Returns the improved size, which might be unmodified.
  */
-unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)
+unsigned int sdio_align_size_dup(struct sdio_func *func, unsigned int sz)
 {
 	unsigned int orig_sz;
 	unsigned int blk_sz, byte_sz;
@@ -225,7 +225,7 @@ unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)
 	 * wants to increase the size up to a point where it
 	 * might need more than one block.
 	 */
-	sz = mmc_align_data_size(func->card, sz);
+	sz = mmc_align_data_size_dup(func->card, sz);
 
 	/*
 	 * If we can still do this with just a byte transfer, then
@@ -247,7 +247,7 @@ unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)
 		 */
 		blk_sz = ((sz + func->cur_blksize - 1) /
 			func->cur_blksize) * func->cur_blksize;
-		blk_sz = mmc_align_data_size(func->card, blk_sz);
+		blk_sz = mmc_align_data_size_dup(func->card, blk_sz);
 
 		/*
 		 * This value is only good if it is still just
@@ -260,7 +260,7 @@ unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)
 		 * We failed to do one request, but at least try to
 		 * pad the remainder properly.
 		 */
-		byte_sz = mmc_align_data_size(func->card,
+		byte_sz = mmc_align_data_size_dup(func->card,
 				sz % func->cur_blksize);
 		if (byte_sz <= sdio_max_byte_size(func)) {
 			blk_sz = sz / func->cur_blksize;
@@ -271,7 +271,7 @@ unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)
 		 * We need multiple requests, so first check that the
 		 * controller can handle the chunk size;
 		 */
-		chunk_sz = mmc_align_data_size(func->card,
+		chunk_sz = mmc_align_data_size_dup(func->card,
 				sdio_max_byte_size(func));
 		if (chunk_sz == sdio_max_byte_size(func)) {
 			/*
@@ -279,7 +279,7 @@ unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)
 			 */
 			byte_sz = orig_sz % chunk_sz;
 			if (byte_sz) {
-				byte_sz = mmc_align_data_size(func->card,
+				byte_sz = mmc_align_data_size_dup(func->card,
 						byte_sz);
 			}
 
@@ -293,7 +293,7 @@ unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)
 	 */
 	return orig_sz;
 }
-EXPORT_SYMBOL_GPL(sdio_align_size);
+EXPORT_SYMBOL_GPL(sdio_align_size_dup);
 
 /* Split an arbitrarily sized data transfer into several
  * IO_RW_EXTENDED commands. */
@@ -352,7 +352,7 @@ static int sdio_io_rw_ext_helper(struct sdio_func *func, int write,
 }
 
 /**
- *	sdio_readb - read a single byte from a SDIO function
+ *	sdio_readb_dup - read a single byte from a SDIO function
  *	@func: SDIO function to access
  *	@addr: address to read
  *	@err_ret: optional status value from transfer
@@ -361,7 +361,7 @@ static int sdio_io_rw_ext_helper(struct sdio_func *func, int write,
  *	function. If there is a problem reading the address, 0xff
  *	is returned and @err_ret will contain the error code.
  */
-u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret)
+u8 sdio_readb_dup(struct sdio_func *func, unsigned int addr, int *err_ret)
 {
 	int ret;
 	u8 val;
@@ -380,10 +380,10 @@ u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret)
 
 	return val;
 }
-EXPORT_SYMBOL_GPL(sdio_readb);
+EXPORT_SYMBOL_GPL(sdio_readb_dup);
 
 /**
- *	sdio_writeb - write a single byte to a SDIO function
+ *	sdio_writeb_dup - write a single byte to a SDIO function
  *	@func: SDIO function to access
  *	@b: byte to write
  *	@addr: address to write to
@@ -393,7 +393,7 @@ EXPORT_SYMBOL_GPL(sdio_readb);
  *	function. @err_ret will contain the status of the actual
  *	transfer.
  */
-void sdio_writeb(struct sdio_func *func, u8 b, unsigned int addr, int *err_ret)
+void sdio_writeb_dup(struct sdio_func *func, u8 b, unsigned int addr, int *err_ret)
 {
 	int ret;
 
@@ -403,10 +403,10 @@ void sdio_writeb(struct sdio_func *func, u8 b, unsigned int addr, int *err_ret)
 	if (err_ret)
 		*err_ret = ret;
 }
-EXPORT_SYMBOL_GPL(sdio_writeb);
+EXPORT_SYMBOL_GPL(sdio_writeb_dup);
 
 /**
- *	sdio_writeb_readb - write and read a byte from SDIO function
+ *	sdio_writeb_dup_readb - write and read a byte from SDIO function
  *	@func: SDIO function to access
  *	@write_byte: byte to write
  *	@addr: address to write to
@@ -418,7 +418,7 @@ EXPORT_SYMBOL_GPL(sdio_writeb);
  *	If there is a problem with the operation, 0xff is returned and
  *	@err_ret will contain the error code.
  */
-u8 sdio_writeb_readb(struct sdio_func *func, u8 write_byte,
+u8 sdio_writeb_dup_readb(struct sdio_func *func, u8 write_byte,
 	unsigned int addr, int *err_ret)
 {
 	int ret;
@@ -433,10 +433,10 @@ u8 sdio_writeb_readb(struct sdio_func *func, u8 write_byte,
 
 	return val;
 }
-EXPORT_SYMBOL_GPL(sdio_writeb_readb);
+EXPORT_SYMBOL_GPL(sdio_writeb_dup_readb);
 
 /**
- *	sdio_memcpy_fromio - read a chunk of memory from a SDIO function
+ *	sdio_memcpy_fromio_dup - read a chunk of memory from a SDIO function
  *	@func: SDIO function to access
  *	@dst: buffer to store the data
  *	@addr: address to begin reading from
@@ -445,15 +445,15 @@ EXPORT_SYMBOL_GPL(sdio_writeb_readb);
  *	Reads from the address space of a given SDIO function. Return
  *	value indicates if the transfer succeeded or not.
  */
-int sdio_memcpy_fromio(struct sdio_func *func, void *dst,
+int sdio_memcpy_fromio_dup(struct sdio_func *func, void *dst,
 	unsigned int addr, int count)
 {
 	return sdio_io_rw_ext_helper(func, 0, addr, 1, dst, count);
 }
-EXPORT_SYMBOL_GPL(sdio_memcpy_fromio);
+EXPORT_SYMBOL_GPL(sdio_memcpy_fromio_dup);
 
 /**
- *	sdio_memcpy_toio - write a chunk of memory to a SDIO function
+ *	sdio_memcpy_toio_dup - write a chunk of memory to a SDIO function
  *	@func: SDIO function to access
  *	@addr: address to start writing to
  *	@src: buffer that contains the data to write
@@ -462,15 +462,15 @@ EXPORT_SYMBOL_GPL(sdio_memcpy_fromio);
  *	Writes to the address space of a given SDIO function. Return
  *	value indicates if the transfer succeeded or not.
  */
-int sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,
+int sdio_memcpy_toio_dup(struct sdio_func *func, unsigned int addr,
 	void *src, int count)
 {
 	return sdio_io_rw_ext_helper(func, 1, addr, 1, src, count);
 }
-EXPORT_SYMBOL_GPL(sdio_memcpy_toio);
+EXPORT_SYMBOL_GPL(sdio_memcpy_toio_dup);
 
 /**
- *	sdio_readsb - read from a FIFO on a SDIO function
+ *	sdio_readsb_dup - read from a FIFO on a SDIO function
  *	@func: SDIO function to access
  *	@dst: buffer to store the data
  *	@addr: address of (single byte) FIFO
@@ -479,15 +479,15 @@ EXPORT_SYMBOL_GPL(sdio_memcpy_toio);
  *	Reads from the specified FIFO of a given SDIO function. Return
  *	value indicates if the transfer succeeded or not.
  */
-int sdio_readsb(struct sdio_func *func, void *dst, unsigned int addr,
+int sdio_readsb_dup(struct sdio_func *func, void *dst, unsigned int addr,
 	int count)
 {
 	return sdio_io_rw_ext_helper(func, 0, addr, 0, dst, count);
 }
-EXPORT_SYMBOL_GPL(sdio_readsb);
+EXPORT_SYMBOL_GPL(sdio_readsb_dup);
 
 /**
- *	sdio_writesb - write to a FIFO of a SDIO function
+ *	sdio_writesb_dup - write to a FIFO of a SDIO function
  *	@func: SDIO function to access
  *	@addr: address of (single byte) FIFO
  *	@src: buffer that contains the data to write
@@ -496,15 +496,15 @@ EXPORT_SYMBOL_GPL(sdio_readsb);
  *	Writes to the specified FIFO of a given SDIO function. Return
  *	value indicates if the transfer succeeded or not.
  */
-int sdio_writesb(struct sdio_func *func, unsigned int addr, void *src,
+int sdio_writesb_dup(struct sdio_func *func, unsigned int addr, void *src,
 	int count)
 {
 	return sdio_io_rw_ext_helper(func, 1, addr, 0, src, count);
 }
-EXPORT_SYMBOL_GPL(sdio_writesb);
+EXPORT_SYMBOL_GPL(sdio_writesb_dup);
 
 /**
- *	sdio_readw - read a 16 bit integer from a SDIO function
+ *	sdio_readw_dup - read a 16 bit integer from a SDIO function
  *	@func: SDIO function to access
  *	@addr: address to read
  *	@err_ret: optional status value from transfer
@@ -513,14 +513,14 @@ EXPORT_SYMBOL_GPL(sdio_writesb);
  *	function. If there is a problem reading the address, 0xffff
  *	is returned and @err_ret will contain the error code.
  */
-u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret)
+u16 sdio_readw_dup(struct sdio_func *func, unsigned int addr, int *err_ret)
 {
 	int ret;
 
 	if (err_ret)
 		*err_ret = 0;
 
-	ret = sdio_memcpy_fromio(func, func->tmpbuf, addr, 2);
+	ret = sdio_memcpy_fromio_dup(func, func->tmpbuf, addr, 2);
 	if (ret) {
 		if (err_ret)
 			*err_ret = ret;
@@ -529,10 +529,10 @@ u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret)
 
 	return le16_to_cpup((__le16 *)func->tmpbuf);
 }
-EXPORT_SYMBOL_GPL(sdio_readw);
+EXPORT_SYMBOL_GPL(sdio_readw_dup);
 
 /**
- *	sdio_writew - write a 16 bit integer to a SDIO function
+ *	sdio_writew_dup - write a 16 bit integer to a SDIO function
  *	@func: SDIO function to access
  *	@b: integer to write
  *	@addr: address to write to
@@ -542,20 +542,20 @@ EXPORT_SYMBOL_GPL(sdio_readw);
  *	function. @err_ret will contain the status of the actual
  *	transfer.
  */
-void sdio_writew(struct sdio_func *func, u16 b, unsigned int addr, int *err_ret)
+void sdio_writew_dup(struct sdio_func *func, u16 b, unsigned int addr, int *err_ret)
 {
 	int ret;
 
 	*(__le16 *)func->tmpbuf = cpu_to_le16(b);
 
-	ret = sdio_memcpy_toio(func, addr, func->tmpbuf, 2);
+	ret = sdio_memcpy_toio_dup(func, addr, func->tmpbuf, 2);
 	if (err_ret)
 		*err_ret = ret;
 }
-EXPORT_SYMBOL_GPL(sdio_writew);
+EXPORT_SYMBOL_GPL(sdio_writew_dup);
 
 /**
- *	sdio_readl - read a 32 bit integer from a SDIO function
+ *	sdio_readl_dup - read a 32 bit integer from a SDIO function
  *	@func: SDIO function to access
  *	@addr: address to read
  *	@err_ret: optional status value from transfer
@@ -565,14 +565,14 @@ EXPORT_SYMBOL_GPL(sdio_writew);
  *	0xffffffff is returned and @err_ret will contain the error
  *	code.
  */
-u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret)
+u32 sdio_readl_dup(struct sdio_func *func, unsigned int addr, int *err_ret)
 {
 	int ret;
 
 	if (err_ret)
 		*err_ret = 0;
 
-	ret = sdio_memcpy_fromio(func, func->tmpbuf, addr, 4);
+	ret = sdio_memcpy_fromio_dup(func, func->tmpbuf, addr, 4);
 	if (ret) {
 		if (err_ret)
 			*err_ret = ret;
@@ -581,10 +581,10 @@ u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret)
 
 	return le32_to_cpup((__le32 *)func->tmpbuf);
 }
-EXPORT_SYMBOL_GPL(sdio_readl);
+EXPORT_SYMBOL_GPL(sdio_readl_dup);
 
 /**
- *	sdio_writel - write a 32 bit integer to a SDIO function
+ *	sdio_writel_dup - write a 32 bit integer to a SDIO function
  *	@func: SDIO function to access
  *	@b: integer to write
  *	@addr: address to write to
@@ -594,20 +594,20 @@ EXPORT_SYMBOL_GPL(sdio_readl);
  *	function. @err_ret will contain the status of the actual
  *	transfer.
  */
-void sdio_writel(struct sdio_func *func, u32 b, unsigned int addr, int *err_ret)
+void sdio_writel_dup(struct sdio_func *func, u32 b, unsigned int addr, int *err_ret)
 {
 	int ret;
 
 	*(__le32 *)func->tmpbuf = cpu_to_le32(b);
 
-	ret = sdio_memcpy_toio(func, addr, func->tmpbuf, 4);
+	ret = sdio_memcpy_toio_dup(func, addr, func->tmpbuf, 4);
 	if (err_ret)
 		*err_ret = ret;
 }
-EXPORT_SYMBOL_GPL(sdio_writel);
+EXPORT_SYMBOL_GPL(sdio_writel_dup);
 
 /**
- *	sdio_f0_readb - read a single byte from SDIO function 0
+ *	sdio_f0_readb_dup - read a single byte from SDIO function 0
  *	@func: an SDIO function of the card
  *	@addr: address to read
  *	@err_ret: optional status value from transfer
@@ -616,7 +616,7 @@ EXPORT_SYMBOL_GPL(sdio_writel);
  *	If there is a problem reading the address, 0xff is returned
  *	and @err_ret will contain the error code.
  */
-unsigned char sdio_f0_readb(struct sdio_func *func, unsigned int addr,
+unsigned char sdio_f0_readb_dup(struct sdio_func *func, unsigned int addr,
 	int *err_ret)
 {
 	int ret;
@@ -636,10 +636,10 @@ unsigned char sdio_f0_readb(struct sdio_func *func, unsigned int addr,
 
 	return val;
 }
-EXPORT_SYMBOL_GPL(sdio_f0_readb);
+EXPORT_SYMBOL_GPL(sdio_f0_readb_dup);
 
 /**
- *	sdio_f0_writeb - write a single byte to SDIO function 0
+ *	sdio_f0_writeb_dup - write a single byte to SDIO function 0
  *	@func: an SDIO function of the card
  *	@b: byte to write
  *	@addr: address to write to
@@ -652,7 +652,7 @@ EXPORT_SYMBOL_GPL(sdio_f0_readb);
  *	0xFF) are permiited; @err_ret will be set to -EINVAL for *
  *	writes outside this range.
  */
-void sdio_f0_writeb(struct sdio_func *func, unsigned char b, unsigned int addr,
+void sdio_f0_writeb_dup(struct sdio_func *func, unsigned char b, unsigned int addr,
 	int *err_ret)
 {
 	int ret;
@@ -669,10 +669,10 @@ void sdio_f0_writeb(struct sdio_func *func, unsigned char b, unsigned int addr,
 	if (err_ret)
 		*err_ret = ret;
 }
-EXPORT_SYMBOL_GPL(sdio_f0_writeb);
+EXPORT_SYMBOL_GPL(sdio_f0_writeb_dup);
 
 /**
- *	sdio_get_host_pm_caps - get host power management capabilities
+ *	sdio_get_host_pm_caps_dup - get host power management capabilities
  *	@func: SDIO function attached to host
  *
  *	Returns a capability bitmask corresponding to power management
@@ -681,28 +681,28 @@ EXPORT_SYMBOL_GPL(sdio_f0_writeb);
  *	to be claimed, nor the function active, for this information to be
  *	obtained.
  */
-mmc_pm_flag_t sdio_get_host_pm_caps(struct sdio_func *func)
+mmc_pm_flag_t sdio_get_host_pm_caps_dup(struct sdio_func *func)
 {
 	BUG_ON(!func);
 	BUG_ON(!func->card);
 
 	return func->card->host->pm_caps;
 }
-EXPORT_SYMBOL_GPL(sdio_get_host_pm_caps);
+EXPORT_SYMBOL_GPL(sdio_get_host_pm_caps_dup);
 
 /**
- *	sdio_set_host_pm_flags - set wanted host power management capabilities
+ *	sdio_set_host_pm_flags_dup - set wanted host power management capabilities
  *	@func: SDIO function attached to host
  *
  *	Set a capability bitmask corresponding to wanted host controller
  *	power management features for the upcoming suspend state.
  *	This must be called, if needed, each time the suspend method of
  *	the function driver is called, and must contain only bits that
- *	were returned by sdio_get_host_pm_caps().
+ *	were returned by sdio_get_host_pm_caps_dup().
  *	The host doesn't need to be claimed, nor the function active,
  *	for this information to be set.
  */
-int sdio_set_host_pm_flags(struct sdio_func *func, mmc_pm_flag_t flags)
+int sdio_set_host_pm_flags_dup(struct sdio_func *func, mmc_pm_flag_t flags)
 {
 	struct mmc_host *host;
 
@@ -718,4 +718,4 @@ int sdio_set_host_pm_flags(struct sdio_func *func, mmc_pm_flag_t flags)
 	host->pm_flags |= flags;
 	return 0;
 }
-EXPORT_SYMBOL_GPL(sdio_set_host_pm_flags);
+EXPORT_SYMBOL_GPL(sdio_set_host_pm_flags_dup);
diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index bb192f9..cc24eef 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -101,11 +101,11 @@ static int sdio_irq_thread(void *_host)
 		 * holding of the host lock does not cover too much work
 		 * that doesn't require that lock to be held.
 		 */
-		ret = __mmc_claim_host(host, &host->sdio_irq_thread_abort);
+		ret = __mmc_claim_host_dup(host, &host->sdio_irq_thread_abort);
 		if (ret)
 			break;
 		ret = process_sdio_pending_irqs(host->card);
-		mmc_release_host(host);
+		mmc_release_host_dup(host);
 
 		/*
 		 * Give other threads a chance to run in the presence of
@@ -187,16 +187,16 @@ static int sdio_card_irq_put(struct mmc_card *card)
 }
 
 /**
- *	sdio_claim_irq - claim the IRQ for a SDIO function
+ *	sdio_claim_irq_dup - claim the IRQ for a SDIO function
  *	@func: SDIO function
  *	@handler: IRQ handler callback
  *
  *	Claim and activate the IRQ for the given SDIO function. The provided
  *	handler will be called when that IRQ is asserted.  The host is always
  *	claimed already when the handler is called so the handler must not
- *	call sdio_claim_host() nor sdio_release_host().
+ *	call sdio_claim_host_dup() nor sdio_release_host_dup().
  */
-int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
+int sdio_claim_irq_dup(struct sdio_func *func, sdio_irq_handler_t *handler)
 {
 	int ret;
 	unsigned char reg;
@@ -230,15 +230,15 @@ int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(sdio_claim_irq);
+EXPORT_SYMBOL_GPL(sdio_claim_irq_dup);
 
 /**
- *	sdio_release_irq - release the IRQ for a SDIO function
+ *	sdio_release_irq_dup - release the IRQ for a SDIO function
  *	@func: SDIO function
  *
  *	Disable and release the IRQ for the given SDIO function.
  */
-int sdio_release_irq(struct sdio_func *func)
+int sdio_release_irq_dup(struct sdio_func *func)
 {
 	int ret;
 	unsigned char reg;
@@ -269,5 +269,5 @@ int sdio_release_irq(struct sdio_func *func)
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(sdio_release_irq);
+EXPORT_SYMBOL_GPL(sdio_release_irq_dup);
 
diff --git a/drivers/mmc/core/sdio_ops.c b/drivers/mmc/core/sdio_ops.c
index dea36d9..5d0c42c 100644
--- a/drivers/mmc/core/sdio_ops.c
+++ b/drivers/mmc/core/sdio_ops.c
@@ -33,7 +33,7 @@ int mmc_send_io_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)
 	cmd.flags = MMC_RSP_SPI_R4 | MMC_RSP_R4 | MMC_CMD_BCR;
 
 	for (i = 100; i; i--) {
-		err = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);
+		err = mmc_wait_for_cmd_dup(host, &cmd, MMC_CMD_RETRIES);
 		if (err)
 			break;
 
@@ -90,7 +90,7 @@ static int mmc_io_rw_direct_host(struct mmc_host *host, int write, unsigned fn,
 	cmd.arg |= in;
 	cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;
 
-	err = mmc_wait_for_cmd(host, &cmd, 0);
+	err = mmc_wait_for_cmd_dup(host, &cmd, 0);
 	if (err)
 		return err;
 
@@ -166,9 +166,9 @@ int mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,
 
 	sg_init_one(&sg, buf, blksz * blocks);
 
-	mmc_set_data_timeout(&data, card);
+	mmc_set_data_timeout_dup(&data, card);
 
-	mmc_wait_for_req(card->host, &mrq);
+	mmc_wait_for_req_dup(card->host, &mrq);
 
 	if (cmd.error)
 		return cmd.error;
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index daadbd6..eb84a78 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -236,7 +236,7 @@ struct mmc_driver {
 	int (*resume)(struct mmc_card *);
 };
 
-extern int mmc_register_driver(struct mmc_driver *);
-extern void mmc_unregister_driver(struct mmc_driver *);
+extern int mmc_register_driver_dup(struct mmc_driver *);
+extern void mmc_unregister_driver_dup(struct mmc_driver *);
 
 #endif
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index 64e013f..01a43ec 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -131,9 +131,9 @@ struct mmc_request {
 struct mmc_host;
 struct mmc_card;
 
-extern void mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
-extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
-extern int mmc_wait_for_app_cmd(struct mmc_host *, struct mmc_card *,
+extern void mmc_wait_for_req_dup(struct mmc_host *, struct mmc_request *);
+extern int mmc_wait_for_cmd_dup(struct mmc_host *, struct mmc_command *, int);
+extern int mmc_wait_for_app_cmd_dup(struct mmc_host *, struct mmc_card *,
 	struct mmc_command *, int);
 
 #define MMC_ERASE_ARG		0x00000000
@@ -145,22 +145,22 @@ extern int mmc_wait_for_app_cmd(struct mmc_host *, struct mmc_card *,
 #define MMC_SECURE_ARGS		0x80000000
 #define MMC_TRIM_ARGS		0x00008001
 
-extern int mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,
+extern int mmc_erase_dup(struct mmc_card *card, unsigned int from, unsigned int nr,
 		     unsigned int arg);
-extern int mmc_can_erase(struct mmc_card *card);
-extern int mmc_can_trim(struct mmc_card *card);
-extern int mmc_can_secure_erase_trim(struct mmc_card *card);
-extern int mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,
+extern int mmc_can_erase_dup(struct mmc_card *card);
+extern int mmc_can_trim_dup(struct mmc_card *card);
+extern int mmc_can_secure_erase_trim_dup(struct mmc_card *card);
+extern int mmc_erase_dup_group_aligned(struct mmc_card *card, unsigned int from,
 				   unsigned int nr);
 
-extern int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen);
+extern int mmc_set_blocklen_dup(struct mmc_card *card, unsigned int blocklen);
 
-extern void mmc_set_data_timeout(struct mmc_data *, const struct mmc_card *);
-extern unsigned int mmc_align_data_size(struct mmc_card *, unsigned int);
+extern void mmc_set_data_timeout_dup(struct mmc_data *, const struct mmc_card *);
+extern unsigned int mmc_align_data_size_dup(struct mmc_card *, unsigned int);
 
-extern int __mmc_claim_host(struct mmc_host *host, atomic_t *abort);
-extern void mmc_release_host(struct mmc_host *host);
-extern int mmc_try_claim_host(struct mmc_host *host);
+extern int __mmc_claim_host_dup(struct mmc_host *host, atomic_t *abort);
+extern void mmc_release_host_dup(struct mmc_host *host);
+extern int mmc_try_claim_host_dup(struct mmc_host *host);
 
 /**
  *	mmc_claim_host - exclusively claim a host
@@ -170,9 +170,9 @@ extern int mmc_try_claim_host(struct mmc_host *host);
  */
 static inline void mmc_claim_host(struct mmc_host *host)
 {
-	__mmc_claim_host(host, NULL);
+	__mmc_claim_host_dup(host, NULL);
 }
 
-extern u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max);
+extern u32 mmc_vddrange_to_ocrmask_dup(int vdd_min, int vdd_max);
 
 #endif
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 0cd9ee7..65f2e61 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -92,12 +92,12 @@ struct mmc_host_ops {
 	 *
 	 * In the case where a host function (like set_ios) may be called
 	 * with or without the host claimed, enabling and disabling can be
-	 * done directly and will nest correctly. Call 'mmc_host_enable()' and
-	 * 'mmc_host_lazy_disable()' for this purpose, but note that these
+	 * done directly and will nest correctly. Call 'mmc_host_enable_dup()' and
+	 * 'mmc_host_lazy_disable_dup()' for this purpose, but note that these
 	 * functions must be paired.
 	 *
-	 * Alternatively, 'mmc_host_enable()' may be paired with
-	 * 'mmc_host_disable()' which calls 'disable' immediately.  In this
+	 * Alternatively, 'mmc_host_enable_dup()' may be paired with
+	 * 'mmc_host_disable_dup()' which calls 'disable' immediately.  In this
 	 * case the 'disable' method will be called with 'lazy' set to 0.
 	 * This is mainly useful for error paths.
 	 *
@@ -264,10 +264,10 @@ struct mmc_host {
 	unsigned long		private[0] ____cacheline_aligned;
 };
 
-extern struct mmc_host *mmc_alloc_host(int extra, struct device *);
-extern int mmc_add_host(struct mmc_host *);
-extern void mmc_remove_host(struct mmc_host *);
-extern void mmc_free_host(struct mmc_host *);
+extern struct mmc_host *mmc_alloc_host_dup(int extra, struct device *);
+extern int mmc_add_host_dup(struct mmc_host *);
+extern void mmc_remove_host_dup(struct mmc_host *);
+extern void mmc_free_host_dup(struct mmc_host *);
 
 static inline void *mmc_priv(struct mmc_host *host)
 {
@@ -280,14 +280,14 @@ static inline void *mmc_priv(struct mmc_host *host)
 #define mmc_classdev(x)	(&(x)->class_dev)
 #define mmc_hostname(x)	(dev_name(&(x)->class_dev))
 
-extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
-extern int mmc_resume_host(struct mmc_host *);
+extern int mmc_suspend_host_dup(struct mmc_host *, pm_message_t);
+extern int mmc_resume_host_dup(struct mmc_host *);
 
-extern int mmc_power_save_host(struct mmc_host *host);
-extern int mmc_power_restore_host(struct mmc_host *host);
+extern int mmc_power_save_host_dup(struct mmc_host *host);
+extern int mmc_power_restore_host_dup(struct mmc_host *host);
 
-extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
-extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
+extern void mmc_detect_change_dup(struct mmc_host *, unsigned long delay);
+extern void mmc_request_done_dup(struct mmc_host *, struct mmc_request *);
 
 static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 {
@@ -297,16 +297,16 @@ static inline void mmc_signal_sdio_irq(struct mmc_host *host)
 
 struct regulator;
 
-int mmc_regulator_get_ocrmask(struct regulator *supply);
-int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit);
+int mmc_regulator_get_ocrmask_dup(struct regulator *supply);
+int mmc_regulator_set_ocr_dup(struct regulator *supply, unsigned short vdd_bit);
 
-int mmc_card_awake(struct mmc_host *host);
-int mmc_card_sleep(struct mmc_host *host);
-int mmc_card_can_sleep(struct mmc_host *host);
+int mmc_card_awake_dup(struct mmc_host *host);
+int mmc_card_sleep_dup(struct mmc_host *host);
+int mmc_card_can_sleep_dup(struct mmc_host *host);
 
-int mmc_host_enable(struct mmc_host *host);
-int mmc_host_disable(struct mmc_host *host);
-int mmc_host_lazy_disable(struct mmc_host *host);
+int mmc_host_enable_dup(struct mmc_host *host);
+int mmc_host_disable_dup(struct mmc_host *host);
+int mmc_host_lazy_disable_dup(struct mmc_host *host);
 int mmc_pm_notify(struct notifier_block *notify_block, unsigned long, void *);
 
 static inline void mmc_set_disable_delay(struct mmc_host *host,
@@ -316,11 +316,11 @@ static inline void mmc_set_disable_delay(struct mmc_host *host,
 }
 
 /* Module parameter */
-extern int mmc_assume_removable;
+extern int mmc_assume_removable_dup;
 
 static inline int mmc_card_is_removable(struct mmc_host *host)
 {
-	return !(host->caps & MMC_CAP_NONREMOVABLE) && mmc_assume_removable;
+	return !(host->caps & MMC_CAP_NONREMOVABLE) && mmc_assume_removable_dup;
 }
 
 #endif
diff --git a/include/linux/mmc/sdio_func.h b/include/linux/mmc/sdio_func.h
index 31baaf8..80ff092 100644
--- a/include/linux/mmc/sdio_func.h
+++ b/include/linux/mmc/sdio_func.h
@@ -110,56 +110,56 @@ struct sdio_driver {
 	.class = (dev_class), \
 	.vendor = SDIO_ANY_ID, .device = SDIO_ANY_ID
 
-extern int sdio_register_driver(struct sdio_driver *);
-extern void sdio_unregister_driver(struct sdio_driver *);
+extern int sdio_register_driver_dup(struct sdio_driver *);
+extern void sdio_unregister_driver_dup(struct sdio_driver *);
 
 /*
  * SDIO I/O operations
  */
-extern void sdio_claim_host(struct sdio_func *func);
-extern void sdio_release_host(struct sdio_func *func);
+extern void sdio_claim_host_dup(struct sdio_func *func);
+extern void sdio_release_host_dup(struct sdio_func *func);
 
-extern int sdio_enable_func(struct sdio_func *func);
-extern int sdio_disable_func(struct sdio_func *func);
+extern int sdio_enable_func_dup(struct sdio_func *func);
+extern int sdio_disable_func_dup(struct sdio_func *func);
 
-extern int sdio_set_block_size(struct sdio_func *func, unsigned blksz);
+extern int sdio_set_block_size_dup(struct sdio_func *func, unsigned blksz);
 
-extern int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler);
-extern int sdio_release_irq(struct sdio_func *func);
+extern int sdio_claim_irq_dup(struct sdio_func *func, sdio_irq_handler_t *handler);
+extern int sdio_release_irq_dup(struct sdio_func *func);
 
-extern unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz);
+extern unsigned int sdio_align_size_dup(struct sdio_func *func, unsigned int sz);
 
-extern u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret);
-extern u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret);
-extern u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret);
+extern u8 sdio_readb_dup(struct sdio_func *func, unsigned int addr, int *err_ret);
+extern u16 sdio_readw_dup(struct sdio_func *func, unsigned int addr, int *err_ret);
+extern u32 sdio_readl_dup(struct sdio_func *func, unsigned int addr, int *err_ret);
 
-extern int sdio_memcpy_fromio(struct sdio_func *func, void *dst,
+extern int sdio_memcpy_fromio_dup(struct sdio_func *func, void *dst,
 	unsigned int addr, int count);
-extern int sdio_readsb(struct sdio_func *func, void *dst,
+extern int sdio_readsb_dup(struct sdio_func *func, void *dst,
 	unsigned int addr, int count);
 
-extern void sdio_writeb(struct sdio_func *func, u8 b,
+extern void sdio_writeb_dup(struct sdio_func *func, u8 b,
 	unsigned int addr, int *err_ret);
-extern void sdio_writew(struct sdio_func *func, u16 b,
+extern void sdio_writew_dup(struct sdio_func *func, u16 b,
 	unsigned int addr, int *err_ret);
-extern void sdio_writel(struct sdio_func *func, u32 b,
+extern void sdio_writel_dup(struct sdio_func *func, u32 b,
 	unsigned int addr, int *err_ret);
 
-extern u8 sdio_writeb_readb(struct sdio_func *func, u8 write_byte,
+extern u8 sdio_writeb_dup_readb(struct sdio_func *func, u8 write_byte,
 	unsigned int addr, int *err_ret);
 
-extern int sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,
+extern int sdio_memcpy_toio_dup(struct sdio_func *func, unsigned int addr,
 	void *src, int count);
-extern int sdio_writesb(struct sdio_func *func, unsigned int addr,
+extern int sdio_writesb_dup(struct sdio_func *func, unsigned int addr,
 	void *src, int count);
 
-extern unsigned char sdio_f0_readb(struct sdio_func *func,
+extern unsigned char sdio_f0_readb_dup(struct sdio_func *func,
 	unsigned int addr, int *err_ret);
-extern void sdio_f0_writeb(struct sdio_func *func, unsigned char b,
+extern void sdio_f0_writeb_dup(struct sdio_func *func, unsigned char b,
 	unsigned int addr, int *err_ret);
 
-extern mmc_pm_flag_t sdio_get_host_pm_caps(struct sdio_func *func);
-extern int sdio_set_host_pm_flags(struct sdio_func *func, mmc_pm_flag_t flags);
+extern mmc_pm_flag_t sdio_get_host_pm_caps_dup(struct sdio_func *func);
+extern int sdio_set_host_pm_flags_dup(struct sdio_func *func, mmc_pm_flag_t flags);
 
 #endif
 
